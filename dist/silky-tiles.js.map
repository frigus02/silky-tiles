{"version":3,"file":"silky-tiles.js","sources":["../src/layouts/flow-layout.js","../src/layouts/column-layout.js","../src/helpers/grid-layout-helper.js","../src/helpers/utils.js","../src/helpers/listenable.js","../src/helpers/drag-handler.js","../src/layouts/base-layout.js","../src/adapters/base-adapter.js","../src/adapters/dom-adapter.js","../src/index.js"],"sourcesContent":["import BaseLayout from './base-layout';\nimport GridLayoutHelper from '../helpers/grid-layout-helper';\n\nexport default class FlowLayout extends BaseLayout {\n    constructor(options) {\n        super();\n\n        this._options = {\n            tileWidth: 96,\n            tileHeight: 96,\n            margin: 8,\n            outerMargin: true,\n            moveMode: 'switch' // switch || push\n        };\n        Object.assign(this._options, options);\n\n        this._tiles = [];\n        this._queue = [];\n\n        this._tilesInRow = 1;\n        this._grid = new GridLayoutHelper();\n        this._height = 0;\n    }\n\n    get height() {\n        return this._height;\n    }\n\n    onLayout(layoutParamsGetter, tilePositionSetter) {\n        const queue = this._queue\n            .map(tile => ({\n                tile,\n                layoutParams: layoutParamsGetter(tile)\n            }))\n            .sort((a, b) => a.layoutParams.position - b.layoutParams.position);\n        this._queue = [];\n\n        queue.forEach(({tile, layoutParams}) => {\n            const {row, col} = this._grid.addTile(tile, layoutParams);\n\n            let translateX = col * (this._options.tileWidth + this._options.margin);\n            let translateY = row * (this._options.tileHeight + this._options.margin);\n            if (this._options.outerMargin) {\n                translateX += this._options.margin;\n                translateY += this._options.margin;\n            }\n\n            this._height = Math.max(\n                this._height,\n                (row + layoutParams.height) * (this._options.tileHeight + this._options.margin) + (this._options.outerMargin ? this._options.margin : -this._options.margin));\n\n            tilePositionSetter(tile, {\n                x: translateX,\n                y: translateY,\n                width: (this._options.tileWidth + this._options.margin) * layoutParams.width - this._options.margin,\n                height: (this._options.tileHeight + this._options.margin) * layoutParams.height - this._options.margin\n            });\n        });\n    }\n\n    onTileAdded(tile) {\n        this._tiles.push(tile);\n        this._queue.push(tile);\n    }\n\n    onTileChanged(tile) {\n        this._grid.reset(this._tilesInRow);\n        this._height = 0;\n        this._queue = [...this._tiles];\n    }\n\n    onTileRemoved(tile) {\n        const index = this._tiles.indexOf(tile);\n        if (index > -1) {\n            this._tiles.splice(index, 1);\n\n            this._grid.reset(this._tilesInRow);\n            this._height = 0;\n            this._queue = [...this._tiles];\n        }\n    }\n\n    onTileMoved(tile, targetTile, layoutParamsGetter) {\n        const position = layoutParamsGetter(tile).position;\n        const targetPosition = layoutParamsGetter(targetTile).position;\n        const changedTiles = [];\n\n        if (this._options.moveMode === 'switch') {\n            changedTiles.push(\n                {\n                    tile: tile,\n                    newPosition: targetPosition\n                },\n                {\n                    tile: targetTile,\n                    newPosition: position\n                }\n            );\n        } else if (this._options.moveMode === 'push') {\n            const tilePositions = {};\n            for (const tile of this._tiles) {\n                const position = layoutParamsGetter(tile).position;\n                tilePositions[position] = tile;\n            }\n\n            const modifier = position > targetPosition ? 1 : -1;\n            changedTiles.push(\n                {\n                    tile: tile,\n                    newPosition: targetPosition\n                },\n                {\n                    tile: targetTile,\n                    newPosition: targetPosition + modifier\n                }\n            );\n\n            const from = Math.min(position, targetPosition) + 1;\n            const to = Math.max(position, targetPosition) - 1;\n\n            for (let middlePosition = from; middlePosition <= to; middlePosition++) {\n                const middleTile = tilePositions[middlePosition];\n                if (middleTile) {\n                    changedTiles.push({\n                        tile: middleTile,\n                        newPosition: middlePosition + modifier\n                    });\n                }\n            }\n        }\n\n        this._grid.reset(this._tilesInRow);\n        this._height = 0;\n        this._queue = [...this._tiles];\n\n        return changedTiles;\n    }\n\n    onWidthChanged(width) {\n        if (this._options.outerMargin) {\n            this._tilesInRow = Math.floor((width - this._options.margin) / (this._options.tileWidth + this._options.margin));\n        } else {\n            this._tilesInRow = Math.floor((width + this._options.margin) / (this._options.tileWidth + this._options.margin));\n        }\n\n        if (this._tilesInRow < 1) {\n            this._tilesInRow = 1;\n        }\n\n        // Need to layout all tiles now.\n        this._grid.reset(this._tilesInRow);\n        this._height = 0;\n        this._queue = [...this._tiles];\n    }\n}\n","import BaseLayout from './base-layout';\nimport GridLayoutHelper from '../helpers/grid-layout-helper';\n\nexport default class ColumnLayout extends BaseLayout {\n    constructor(options) {\n        super();\n\n        this._options = {\n            columns: 5,\n            margin: 8,\n            outerMargin: true,\n            moveMode: 'switch' // switch || push\n        };\n        Object.assign(this._options, options);\n\n        this._tiles = [];\n        this._queue = [];\n        this._grid = new GridLayoutHelper();\n        this._grid.reset(this._options.columns);\n        this._tileWidth = 1;\n        this._height = 0;\n    }\n\n    get height() {\n        return this._height;\n    }\n\n    onLayout(layoutParamsGetter, tilePositionSetter) {\n        const queue = this._queue\n            .map(tile => ({\n                tile,\n                layoutParams: layoutParamsGetter(tile)\n            }))\n            .sort((a, b) => a.layoutParams.position - b.layoutParams.position);\n        this._queue = [];\n\n        queue.forEach(({tile, layoutParams}) => {\n            const {row, col} = this._grid.includesTile(tile)\n                ? this._grid.getTilePosition(tile)\n                : this._grid.addTile(tile, layoutParams);\n\n            let translateX = col * (this._tileWidth + this._options.margin);\n            let translateY = row * (this._tileWidth + this._options.margin);\n            if (this._options.outerMargin) {\n                translateX += this._options.margin;\n                translateY += this._options.margin;\n            }\n\n            this._height = Math.max(\n                this._height,\n                (row + 1) * (this._tileWidth + this._options.margin) + (this._options.outerMargin ? this._options.margin : -this._options.margin));\n\n            tilePositionSetter(tile, {\n                x: translateX,\n                y: translateY,\n                width: (this._tileWidth + this._options.margin) * layoutParams.width - this._options.margin,\n                height: (this._tileWidth + this._options.margin) * layoutParams.height - this._options.margin\n            });\n        });\n\n        return queue;\n    }\n\n    onTileAdded(tile) {\n        this._tiles.push(tile);\n        this._queue.push(tile);\n    }\n\n    onTileChanged(tile) {\n        this._grid.reset(this._tilesInRow);\n        this._height = 0;\n        this._queue = [...this._tiles];\n    }\n\n    onTileRemoved(tile) {\n        const index = this._tiles.indexOf(tile);\n        if (index > -1) {\n            this._tiles.splice(index, 1);\n\n            this._grid.reset(this._tilesInRow);\n            this._height = 0;\n            this._queue = [...this._tiles];\n        }\n    }\n\n    onTileMoved(tile, targetTile, layoutParamsGetter) {\n        const position = layoutParamsGetter(tile).position;\n        const targetPosition = layoutParamsGetter(targetTile).position;\n        const changedTiles = [];\n\n        if (this._options.moveMode === 'switch') {\n            changedTiles.push(\n                {\n                    tile: tile,\n                    newPosition: targetPosition\n                },\n                {\n                    tile: targetTile,\n                    newPosition: position\n                }\n            );\n        } else if (this._options.moveMode === 'push') {\n            const tilePositions = {};\n            for (const tile of this._tiles) {\n                const position = layoutParamsGetter(tile).position;\n                tilePositions[position] = tile;\n            }\n\n            const modifier = position > targetPosition ? 1 : -1;\n            changedTiles.push(\n                {\n                    tile: tile,\n                    newPosition: targetPosition\n                },\n                {\n                    tile: targetTile,\n                    newPosition: targetPosition + modifier\n                }\n            );\n\n            const from = Math.min(position, targetPosition) + 1;\n            const to = Math.max(position, targetPosition) - 1;\n\n            for (let middlePosition = from; middlePosition <= to; middlePosition++) {\n                const middleTile = tilePositions[middlePosition];\n                if (middleTile) {\n                    changedTiles.push({\n                        tile: middleTile,\n                        newPosition: middlePosition + modifier\n                    });\n                }\n            }\n        }\n\n        this._grid.reset(this._tilesInRow);\n        this._height = 0;\n        this._queue = [...this._tiles];\n\n        return changedTiles;\n    }\n\n    onWidthChanged(width) {\n        if (this._options.outerMargin) {\n            this._tileWidth = (width - (this._options.columns + 1) * this._options.margin) / this._options.columns;\n        } else {\n            this._tileWidth = (width - (this._options.columns - 1) * this._options.margin) / this._options.columns;\n        }\n\n        this._height = 0;\n        this._queue = [...this._tiles];\n    }\n}\n","export default class GridLayoutHandler {\n    constructor() {\n        this._grid = [];\n        this._tilesInRow = 1;\n    }\n\n    addTile(tile, layoutParams) {\n        // In case the tile does not fit into the grid at all, at\n        // least make sure it takes to full width.\n        const tileWidth = Math.min(layoutParams.width, this._tilesInRow);\n        const tileHeight = layoutParams.height;\n\n        // Find first free spot\n        let rowIndexStart,\n            rowIndexEnd,\n            colIndexStart,\n            colIndexEnd;\n\n        rowLoop:\n        for (rowIndexStart = 0, rowIndexEnd = tileHeight - 1; ; rowIndexStart++, rowIndexEnd++) {\n            for (colIndexStart = 0, colIndexEnd = tileWidth - 1; colIndexEnd < this._tilesInRow; colIndexStart++, colIndexEnd++) {\n                if (this._doesTileFitIntoPosition(rowIndexStart, rowIndexEnd, colIndexStart, colIndexEnd)) {\n                    break rowLoop;\n                }\n            }\n        }\n\n        // Occupy spot\n        for (let rowIndex = rowIndexStart; rowIndex <= rowIndexEnd; rowIndex++) {\n            while (this._grid.length <= rowIndex) {\n                this._grid.push(new Array(this._tilesInRow));\n            }\n\n            for (let colIndex = colIndexStart; colIndex <= colIndexEnd; colIndex++) {\n                this._grid[rowIndex][colIndex] = tile;\n            }\n        }\n\n        return {\n            row: rowIndexStart,\n            col: colIndexStart\n        };\n    }\n\n    includesTile(tile) {\n        return this._grid.some(r => r.includes(tile));\n    }\n\n    getTilePosition(tile) {\n        const row = this._grid.findIndex(r => r.includes(tile));\n        const col = this._grid[row].indexOf(tile);\n\n        return {\n            row,\n            col\n        };\n    }\n\n    _doesTileFitIntoPosition(rowIndexStart, rowIndexEnd, colIndexStart, colIndexEnd) {\n        for (let rowIndex = rowIndexStart; rowIndex <= rowIndexEnd; rowIndex++) {\n            const row = this._grid[rowIndex];\n            if (!row) break;\n\n            for (let colIndex = colIndexStart; colIndex <= colIndexEnd; colIndex++) {\n                if (typeof row[colIndex] !== 'undefined') {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    reset(tilesInRow) {\n        this._grid = [];\n        this._tilesInRow = tilesInRow;\n    }\n}\n","export function getTouchCoordinate(evt, prop) {\n    if (evt.touches && evt.touches.length > 0) {\n        return evt.touches[0][prop];\n    } else {\n        return evt[prop];\n    }\n}\n","class Listenable {\n    constructor() {\n        this._listeners = {};\n    }\n\n    addEventListener(eventName, callback) {\n        this._getListeners(eventName).push(callback);\n    }\n\n    dispatchEvent(eventName, ...args) {\n        const listeners = this._getListeners(eventName);\n        for (const listener of listeners) {\n            listener(...args);\n        }\n    }\n\n    removeEventListener(eventName, callback) {\n        const listeners = this._getListeners(eventName);\n        const index = listeners.indexOf(callback);\n        if (index > -1) {\n            listeners.splice(index, 1);\n        }\n    }\n\n    _getListeners(eventName) {\n        if (!this._listeners.hasOwnProperty(eventName)) {\n            this._listeners[eventName] = [];\n        }\n\n        return this._listeners[eventName];\n    }\n}\n\nexport default Listenable;\n","import Listenable from './listenable';\nimport {getTouchCoordinate} from './utils';\n\n/**\n * Supported events: dragstart, dragend, tilemoved\n */\nexport default class DragHandler extends Listenable {\n    constructor(silkyTiles) {\n        super();\n\n        this._silkyTiles = silkyTiles;\n        this._adapter = null;\n        this._tile = null;\n        this._startX = 0;\n        this._startY = 0;\n        this._currentX = 0;\n        this._currentY = 0;\n\n        this._initEventListeners = this._initEventListeners.bind(this);\n        this._destroyEventListeners = this._destroyEventListeners.bind(this);\n        this._onDragStart = this._onDragStart.bind(this);\n        this._onDragMove = this._onDragMove.bind(this);\n        this._onDragEnd = this._onDragEnd.bind(this);\n    }\n\n    get adapter() {\n        return this._adapter;\n    }\n\n    set adapter(adapter) {\n        if (this._adapter) {\n            this._adapter.removeEventListener('tileadded', this._initEventListeners);\n            this._adapter.tiles.forEach(this._destroyEventListeners);\n        }\n\n        this._adapter = adapter;\n        this._adapter.tiles.forEach(this._initEventListeners);\n        this._adapter.addEventListener('tileadded', this._initEventListeners);\n    }\n\n    _initEventListeners(tile) {\n        if (window.PointerEvent) {\n            tile.addEventListener('pointerdown', this._onDragStart);\n        } else {\n            tile.addEventListener('touchstart', this._onDragStart);\n            tile.addEventListener('mousedown', this._onDragStart);\n        }\n    }\n\n    _destroyEventListeners(tile) {\n        if (window.PointerEvent) {\n            tile.removeEventListener('pointerdown', this._onDragStart);\n        } else {\n            tile.removeEventListener('touchstart', this._onDragStart);\n            tile.removeEventListener('mousedown', this._onDragStart);\n        }\n    }\n\n    _onDragStart(evt) {\n        if (this._tile) return;\n\n        evt.preventDefault();\n\n        this._tile = evt.currentTarget;\n\n        const currentPosition = this._silkyTiles.getTilePosition(this._tile);\n\n        this._currentX = getTouchCoordinate(evt, 'pageX');\n        this._currentY = getTouchCoordinate(evt, 'pageY');\n        this._startX = this._currentX - currentPosition.x;\n        this._startY = this._currentY - currentPosition.y;\n\n        this._tile.classList.add('st-is-dragging');\n\n        if (window.PointerEvent) {\n            this._tile.addEventListener('pointermove', this._onDragMove);\n            this._tile.addEventListener('pointerup', this._onDragEnd);\n            this._tile.addEventListener('pointercancel', this._onDragEnd);\n\n            this._tile.setPointerCapture(evt.pointerId);\n        } else {\n            document.addEventListener('touchmove', this._onDragMove);\n            document.addEventListener('touchend', this._onDragEnd);\n            document.addEventListener('mousemove', this._onDragMove);\n            document.addEventListener('mouseup', this._onDragEnd);\n        }\n\n        this.dispatchEvent('dragstart', this._tile);\n    }\n\n    _onDragMove(evt) {\n        if (!this._tile) return;\n\n        this._currentX = getTouchCoordinate(evt, 'pageX');\n        this._currentY = getTouchCoordinate(evt, 'pageY');\n    }\n\n    _onDragEnd() {\n        if (!this._tile) return;\n\n        if (window.PointerEvent) {\n            this._tile.removeEventListener('pointermove', this._onDragMove);\n            this._tile.removeEventListener('pointerup', this._onDragEnd);\n            this._tile.removeEventListener('pointercancel', this._onDragEnd);\n        } else {\n            document.removeEventListener('touchmove', this._onDragMove);\n            document.removeEventListener('touchend', this._onDragEnd);\n            document.removeEventListener('mousemove', this._onDragMove);\n            document.removeEventListener('mouseup', this._onDragEnd);\n        }\n\n        this._tile.classList.remove('st-is-dragging');\n\n        this.dispatchEvent('dragend', this._tile);\n\n        this._tile = null;\n    }\n\n    _getTileAtPosition(x, y) {\n        for (let tile of this._adapter.tiles) {\n            const position = this._silkyTiles.getTilePosition(tile);\n\n            if (tile !== this._tile &&\n                x > position.x && x < position.x + position.width &&\n                y > position.y && y < position.y + position.height) {\n                return tile;\n            }\n        }\n    }\n\n    layout() {\n        if (!this._tile) return;\n\n        const containerBounds = this._adapter.getContainerBounds();\n        const targetTile = this._getTileAtPosition(\n            this._currentX - containerBounds.absoluteLeft,\n            this._currentY - containerBounds.absoluteTop);\n\n        if (targetTile) {\n            this.dispatchEvent('tilemoved', this._tile, targetTile);\n        }\n\n        return {\n            x: this._currentX - this._startX,\n            y: this._currentY - this._startY\n        };\n    }\n}\n","export default class BaseLayout {\n    constructor() {\n        this._positions = new WeakMap();\n    }\n\n    get height() {\n    }\n\n    getTilePosition(tile) {\n        return this._positions.get(tile);\n    }\n\n    layout(layoutParamsGetter) {\n        const changedTiles = [];\n        this.onLayout(layoutParamsGetter, (tile, position) => {\n            const lastPosition = this._positions.get(tile);\n            if (!lastPosition ||\n                lastPosition.x !== position.x ||\n                lastPosition.y !== position.y ||\n                lastPosition.width !== position.width ||\n                lastPosition.height !== position.height) {\n                this._positions.set(tile, position);\n                changedTiles.push(tile);\n            }\n        });\n\n        return changedTiles;\n    }\n\n    /**\n     * Called during the layout phase. Implementations should calculate\n     * the new coordinates for all changed tiles and set them using the\n     * passed tilePositionSetter.\n     */\n    onLayout(/*layoutParamsGetter, tilePositionSetter*/) {\n    }\n\n    /**\n     * Called when a new tile is added to the grid. The tile\n     * will always be positioned at the end of the grid.\n     */\n    onTileAdded(/*tile*/) {\n    }\n\n    /**\n     * Called when layout params of a tile change, such as the\n     * position, width or height.\n     */\n    onTileChanged(/*tile*/) {\n    }\n\n    /**\n     * Called when a tile is removed from the grid.\n     */\n    onTileRemoved(/*tile*/) {\n    }\n\n    /**\n     * Called when the user moved a tile from one position to another.\n     * The function gets the tile and the tile it was moved on top on.\n     * It should return new positions for all tiles, which change\n     * as a result of this action.\n     *\n     * @return {Array} Tiles, which changes positions because of the action.\n     */\n    onTileMoved(/*tile, targetTile, layoutParamsGetter*/) {\n        return [\n            /*{\n                tile: someTile,\n                newPosition: 12\n            }*/\n        ];\n    }\n\n    /**\n     * Called when the width of the container has changed.\n     */\n    onWidthChanged(/*width*/) {\n    }\n}\n","import Listenable from '../helpers/listenable';\n\n/**\n * Supported events: tileadded, tilechanged, tileremoved\n */\nexport default class BaseAdapter extends Listenable {\n    constructor() {\n        super();\n    }\n\n    get container() {\n        return undefined;\n    }\n\n    get tiles() {\n        return [];\n    }\n\n    getContainerBounds() {\n        return {\n            /*top: 12,\n            left: 12,\n            absoluteTop: 120,\n            absoluteLeft: 80*/\n        };\n    }\n\n    getTileBounds(/*tile*/) {\n        return {\n            /*width: 100,\n            height: 100,\n            x: 12,\n            y: 12*/\n        };\n    }\n\n    getTileLayoutParams(/*tile*/) {\n    }\n\n    onTilePositionChanged(/*tile, newPosition*/) {\n    }\n}\n","import BaseAdapter from './base-adapter';\n\nexport default class DomAdapter extends BaseAdapter {\n    constructor(containerElement) {\n        super();\n\n        this._containerElement = containerElement;\n        this._containerElement.classList.add('st-container');\n        this._tiles = Array.from(containerElement.children);\n        this._tiles.forEach(tile => {\n            tile.classList.add('st-tile');\n        })\n\n        this._onChildrenMutated = this._onChildrenMutated.bind(this);\n\n        this._observer = new MutationObserver(this._onChildrenMutated);\n        this._observer.observe(containerElement, {\n            childList: true\n        });\n    }\n\n    _onChildrenMutated(records) {\n        for (const record of records) {\n            for (const node of record.addedNodes) {\n                if (node instanceof Element) {\n                    node.classList.add('st-tile');\n                    this._tiles.push(node);\n                    this.dispatchEvent('tileadded', node);\n                }\n            }\n\n            for (const node of record.removedNodes) {\n                if (node instanceof Element) {\n                    const index = this._tiles.indexOf(node);\n                    this._tiles.splice(index, 1);\n                    this.dispatchEvent('tileremoved', node);\n                }\n            }\n        }\n    }\n\n    get container() {\n        return this._containerElement;\n    }\n\n    get tiles() {\n        return this._tiles;\n    }\n\n    getContainerBounds() {\n        const bounds = this._containerElement.getBoundingClientRect();\n\n        let absoluteTop = 0;\n        let absoluteLeft = 0;\n        let currentElement = this._containerElement;\n        do {\n            absoluteTop += currentElement.offsetTop;\n            absoluteLeft += currentElement.offsetLeft;\n            currentElement = currentElement.offsetParent;\n        } while (currentElement);\n\n        return {\n            top: bounds.top,\n            left: bounds.left,\n            absoluteTop,\n            absoluteLeft\n        };\n    }\n\n    getTileBounds(tile) {\n        const containerBounds = this.getContainerBounds();\n        const bounds = tile.getBoundingClientRect();\n\n        return {\n            width: bounds.width,\n            height: bounds.width,\n            x: bounds.left - containerBounds.left,\n            y: bounds.top - containerBounds.top\n        };\n    }\n\n    getTileLayoutParams(tile) {\n        return {\n            position: parseInt(tile.dataset.tilePosition, 10),\n            width: parseInt(tile.dataset.tileWidth, 10) || 1,\n            height: parseInt(tile.dataset.tileHeight, 10) || 1\n        };\n    }\n\n    onTilePositionChanged(tile, newPosition) {\n        tile.dataset.tilePosition = newPosition;\n    }\n}\n","import './styles/minimal.css';\nimport DragHandler from './helpers/drag-handler';\nimport BaseLayout from './layouts/base-layout';\nimport ColumnLayout from './layouts/column-layout';\nimport FlowLayout from './layouts/flow-layout';\nimport BaseAdapter from './adapters/base-adapter';\nimport DomAdapter from './adapters/dom-adapter';\n\nexport class SilkyTiles {\n    constructor() {\n        this._adapter = null;\n        this._layout = null;\n        this._layoutWidth = 0;\n        this._layoutHeight = 0;\n        this._dragHandler = new DragHandler(this);\n        this._draggingTile = null;\n\n        this._onTileAdded = this._onTileAdded.bind(this);\n        this._onTileChanged = this._onTileChanged.bind(this);\n        this._onTileRemoved = this._onTileRemoved.bind(this);\n        this._onTileDragStart = this._onTileDragStart.bind(this);\n        this._onTileDragEnd = this._onTileDragEnd.bind(this);\n        this._onTileMoved = this._onTileMoved.bind(this);\n        this._update = this._update.bind(this);\n\n        this._dragHandler.addEventListener('dragstart', this._onTileDragStart);\n        this._dragHandler.addEventListener('dragend', this._onTileDragEnd);\n        this._dragHandler.addEventListener('tilemoved', this._onTileMoved);\n\n        requestAnimationFrame(this._update);\n    }\n\n    get adapter() {\n        return this._adapter;\n    }\n\n    set adapter(adapter) {\n        if (this._adapter) {\n            this._adapter.removeEventListener('tileadded', this._onTileAdded);\n            this._adapter.removeEventListener('tilechanged', this._onTileChanged);\n            this._adapter.removeEventListener('tileremoved', this._onTileRemoved);\n            this._adapter.tiles.forEach(this._onTileRemoved);\n        }\n\n        this._adapter = adapter;\n        this._adapter.tiles.forEach(this._onTileAdded);\n        this._adapter.addEventListener('tileadded', this._onTileAdded);\n        this._adapter.addEventListener('tilechanged', this._onTileChanged);\n        this._adapter.addEventListener('tileremoved', this._onTileRemoved);\n\n        this._dragHandler.adapter = this._adapter;\n    }\n\n    get layout() {\n        return this._layout;\n    }\n\n    set layout(layout) {\n        if (this._layout && this._adapter) {\n            this._adapter.tiles.forEach(this._onTileRemoved);\n        }\n\n        this._layout = layout;\n        if (this._adapter) {\n            this._adapter.tiles.forEach(this._onTileAdded);\n        }\n    }\n\n    _onTileAdded(tile) {\n        if (this._layout) {\n            this._layout.onTileAdded(tile);\n        }\n    }\n\n    _onTileChanged(tile) {\n        if (this._layout) {\n            this._layout.onTileChanged(tile);\n        }\n    }\n\n    _onTileRemoved(tile) {\n        if (this._layout) {\n            this._layout.onTileRemoved(tile);\n        }\n    }\n\n    _onTileDragStart(tile) {\n        this._draggingTile = tile;\n    }\n\n    _onTileDragEnd(tile) {\n        this._draggingTile = null;\n        this._onTileChanged(tile);\n    }\n\n    _onTileMoved(tile, targetTile) {\n        if (this._layout) {\n            const newPositions = this._layout.onTileMoved(tile, targetTile, tile => this._adapter.getTileLayoutParams(tile));\n            for (const pos of newPositions) {\n                this._adapter.onTilePositionChanged(pos.tile, pos.newPosition);\n            }\n        }\n    }\n\n    _update() {\n        if (!this._adapter || !this._layout) return;\n\n        const changedTiles = [];\n\n        // Get layout from drag handler first, because it might add\n        // additional tiles to the queue.\n        let draggingTilePosition;\n        if (this._draggingTile) {\n            draggingTilePosition = this._dragHandler.layout();\n            changedTiles.push(this._draggingTile);\n        }\n\n        // If the container width changed, we need to layout all tiles.\n        if (this._layoutWidth !== this._adapter.container.clientWidth) {\n            this._layoutWidth = this._adapter.container.clientWidth;\n            this._layout.onWidthChanged(this._layoutWidth);\n        }\n\n        // Get layout queue.\n        changedTiles.push(...this._layout.layout(tile => this._adapter.getTileLayoutParams(tile)));\n\n        // Layout all tiles in queue.\n        for (let tile of changedTiles) {\n            const position = this._layout.getTilePosition(tile);\n            if (tile === this._draggingTile) {\n                Object.assign(position, draggingTilePosition);\n            }\n\n            tile.style.width = `${position.width}px`;\n            tile.style.height = `${position.height}px`;\n            tile.style.transform = `translateX(${position.x}px) translateY(${position.y}px)`;\n        }\n\n        // Update container height.\n        if (this._layoutHeight !== this._layout.height) {\n            this._layoutHeight = this._layout.height;\n            this._adapter.container.style.height = `${this._layoutHeight}px`;\n        }\n\n        requestAnimationFrame(this._update);\n    }\n\n    getTilePosition(tile) {\n        return this._layout && this._layout.getTilePosition(tile);\n    }\n}\n\nexport const layouts = {\n    BaseLayout,\n    ColumnLayout,\n    FlowLayout\n};\n\nexport const adapters = {\n    BaseAdapter,\n    DomAdapter\n};\n"],"names":["Math","floor","max","min","evt","touches","length","prop","Listenable","_listeners","addEventListener","_getListeners","eventName","push","callback","dispatchEvent","listeners","args","listener","removeEventListener","index","indexOf","splice","hasOwnProperty","DragHandler","_Listenable","_silkyTiles","silkyTiles","_adapter","_tile","_startX","_startY","_currentX","_currentY","_initEventListeners","_this","bind","_destroyEventListeners","_onDragStart","_onDragMove","_onDragEnd","window","PointerEvent","preventDefault","currentTarget","currentPosition","getTilePosition","getTouchCoordinate","x","y","classList","add","setPointerCapture","pointerId","remove","_getTileAtPosition","tiles","tile","position","width","height","layout","containerBounds","getContainerBounds","targetTile","absoluteLeft","absoluteTop","forEach","adapter","BaseLayout","_positions","WeakMap","get","changedTiles","onLayout","layoutParamsGetter","lastPosition","set","onTileAdded","onTileChanged","onTileRemoved","onTileMoved","onWidthChanged","GridLayoutHandler","_grid","_tilesInRow","addTile","tileWidth","layoutParams","tileHeight","rowIndexStart","rowIndexEnd","colIndexStart","colIndexEnd","_doesTileFitIntoPosition","rowLoop","rowIndex","Array","colIndex","includesTile","some","r","includes","row","findIndex","col","reset","tilesInRow","ColumnLayout","_BaseLayout","_options","assign","options","_tiles","_queue","GridLayoutHelper","columns","_tileWidth","_height","queue","map","sort","a","b","_this2","translateX","margin","translateY","outerMargin","targetPosition","moveMode","tilePositions","modifier","from","to","middlePosition","middleTile","FlowLayout","BaseAdapter","getTileBounds","getTileLayoutParams","onTilePositionChanged","DomAdapter","_BaseAdapter","_containerElement","containerElement","children","_onChildrenMutated","_observer","MutationObserver","observe","records","record","addedNodes","node","Element","removedNodes","bounds","getBoundingClientRect","currentElement","offsetTop","offsetLeft","offsetParent","top","left","parseInt","dataset","tilePosition","newPosition","SilkyTiles","_layout","_layoutWidth","_layoutHeight","_dragHandler","_draggingTile","_onTileAdded","_onTileChanged","_onTileRemoved","_onTileDragStart","_onTileDragEnd","_onTileMoved","_update","newPositions","pos","draggingTilePosition","container","clientWidth","style","transform"],"mappings":"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"}